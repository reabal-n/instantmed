{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///Users/rey/Desktop/instantmed/instantmed-main/lib/stripe/client.ts"],"sourcesContent":["import \"server-only\"\nimport Stripe from \"stripe\"\n\n// Validate required environment variables\nif (!process.env.STRIPE_SECRET_KEY) {\n  throw new Error(\"Missing STRIPE_SECRET_KEY environment variable\")\n}\n\nexport const stripe = new Stripe(process.env.STRIPE_SECRET_KEY)\n\n// Price ID mapping based on category/subtype\nexport type ServiceCategory = \"medical_certificate\" | \"prescription\" | \"referral\"\n\ninterface PriceIdInput {\n  category: ServiceCategory\n  subtype: string\n  answers?: Record<string, unknown>\n}\n\n/**\n * Get the correct Stripe price ID based on request category, subtype, and answers\n */\nexport function getPriceIdForRequest({ category, subtype, answers }: PriceIdInput): string {\n  // Medical certificates - all use the same price\n  if (category === \"medical_certificate\") {\n    const priceId = process.env.STRIPE_PRICE_MEDCERT\n    if (!priceId) {\n      throw new Error(\"Missing STRIPE_PRICE_MEDCERT environment variable\")\n    }\n    return priceId\n  }\n\n  // Prescriptions - all use the same price\n  if (category === \"prescription\") {\n    const priceId = process.env.STRIPE_PRICE_PRESCRIPTION\n    if (!priceId) {\n      throw new Error(\"Missing STRIPE_PRICE_PRESCRIPTION environment variable\")\n    }\n    return priceId\n  }\n\n  // Referrals - different pricing for imaging vs bloods\n  if (category === \"referral\") {\n    // Check if it's pathology-imaging subtype\n    if (subtype === \"pathology-imaging\" || subtype === \"pathology_imaging\") {\n      // Check if any imaging tests are selected\n      const selectedTests = answers?.test_types as string[] | undefined\n      const imagingTests = [\"xray\", \"ultrasound\", \"ct_mri\"]\n      const hasImaging = selectedTests?.some((test) => imagingTests.includes(test))\n\n      if (hasImaging) {\n        const priceId = process.env.STRIPE_PRICE_IMAGING\n        if (!priceId) {\n          throw new Error(\"Missing STRIPE_PRICE_IMAGING environment variable\")\n        }\n        return priceId\n      } else {\n        const priceId = process.env.STRIPE_PRICE_PATHOLOGY_BLOODS\n        if (!priceId) {\n          throw new Error(\"Missing STRIPE_PRICE_PATHOLOGY_BLOODS environment variable\")\n        }\n        return priceId\n      }\n    }\n\n    // Specialist referrals - use bloods price as default\n    const priceId = process.env.STRIPE_PRICE_PATHOLOGY_BLOODS\n    if (!priceId) {\n      throw new Error(\"Missing STRIPE_PRICE_PATHOLOGY_BLOODS environment variable for specialist referrals\")\n    }\n    return priceId\n  }\n\n  throw new Error(`Unknown category: ${category}`)\n}\n\n/**\n * Get display price for a service category (for UI)\n */\nexport function getDisplayPriceForCategory(category: ServiceCategory): string {\n  switch (category) {\n    case \"medical_certificate\":\n      return \"$19.95\"\n    case \"prescription\":\n      return \"$24.95\"\n    case \"referral\":\n      return \"$29.95\"\n    default:\n      return \"$19.95\"\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAEA,0CAA0C;AAC1C,IAAI,CAAC,QAAQ,GAAG,CAAC,iBAAiB,EAAE;IAClC,MAAM,IAAI,MAAM;AAClB;AAEO,MAAM,SAAS,IAAI,iKAAM,CAAC,QAAQ,GAAG,CAAC,iBAAiB;AAcvD,SAAS,qBAAqB,EAAE,QAAQ,EAAE,OAAO,EAAE,OAAO,EAAgB;IAC/E,gDAAgD;IAChD,IAAI,aAAa,uBAAuB;QACtC,MAAM,UAAU,QAAQ,GAAG,CAAC,oBAAoB;QAChD,IAAI,CAAC,SAAS;YACZ,MAAM,IAAI,MAAM;QAClB;QACA,OAAO;IACT;IAEA,yCAAyC;IACzC,IAAI,aAAa,gBAAgB;QAC/B,MAAM,UAAU,QAAQ,GAAG,CAAC,yBAAyB;QACrD,IAAI,CAAC,SAAS;YACZ,MAAM,IAAI,MAAM;QAClB;QACA,OAAO;IACT;IAEA,sDAAsD;IACtD,IAAI,aAAa,YAAY;QAC3B,0CAA0C;QAC1C,IAAI,YAAY,uBAAuB,YAAY,qBAAqB;YACtE,0CAA0C;YAC1C,MAAM,gBAAgB,SAAS;YAC/B,MAAM,eAAe;gBAAC;gBAAQ;gBAAc;aAAS;YACrD,MAAM,aAAa,eAAe,KAAK,CAAC,OAAS,aAAa,QAAQ,CAAC;YAEvE,IAAI,YAAY;gBACd,MAAM,UAAU,QAAQ,GAAG,CAAC,oBAAoB;gBAChD,IAAI,CAAC,SAAS;oBACZ,MAAM,IAAI,MAAM;gBAClB;gBACA,OAAO;YACT,OAAO;gBACL,MAAM,UAAU,QAAQ,GAAG,CAAC,6BAA6B;gBACzD,IAAI,CAAC,SAAS;oBACZ,MAAM,IAAI,MAAM;gBAClB;gBACA,OAAO;YACT;QACF;QAEA,qDAAqD;QACrD,MAAM,UAAU,QAAQ,GAAG,CAAC,6BAA6B;QACzD,IAAI,CAAC,SAAS;YACZ,MAAM,IAAI,MAAM;QAClB;QACA,OAAO;IACT;IAEA,MAAM,IAAI,MAAM,CAAC,kBAAkB,EAAE,UAAU;AACjD;AAKO,SAAS,2BAA2B,QAAyB;IAClE,OAAQ;QACN,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT;YACE,OAAO;IACX;AACF"}},
    {"offset": {"line": 119, "column": 0}, "map": {"version":3,"sources":["file:///Users/rey/Desktop/instantmed/instantmed-main/lib/supabase/server.ts"],"sourcesContent":["import { createServerClient } from \"@supabase/ssr\"\nimport { cookies } from \"next/headers\"\n\n// Server client for use in Server Components, Route Handlers, and Server Actions\n// Always create a new client within each function - do not store in a global variable\nexport async function createClient() {\n  const cookieStore = await cookies()\n\n  return createServerClient(process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!, {\n    cookies: {\n      getAll() {\n        return cookieStore.getAll()\n      },\n      setAll(cookiesToSet) {\n        try {\n          cookiesToSet.forEach(({ name, value, options }) => cookieStore.set(name, value, options))\n        } catch {\n          // The \"setAll\" method was called from a Server Component.\n          // This can be ignored if you have middleware refreshing user sessions.\n        }\n      },\n    },\n  })\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;;;AAIO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,0IAAO;IAEjC,OAAO,IAAA,+LAAkB,sUAAoF;QAC3G,SAAS;YACP;gBACE,OAAO,YAAY,MAAM;YAC3B;YACA,QAAO,YAAY;gBACjB,IAAI;oBACF,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAAK,YAAY,GAAG,CAAC,MAAM,OAAO;gBAClF,EAAE,OAAM;gBACN,0DAA0D;gBAC1D,uEAAuE;gBACzE;YACF;QACF;IACF;AACF"}},
    {"offset": {"line": 150, "column": 0}, "map": {"version":3,"sources":["file:///Users/rey/Desktop/instantmed/instantmed-main/lib/auth.ts"],"sourcesContent":["import { createClient } from \"@/lib/supabase/server\"\nimport { redirect } from \"next/navigation\"\nimport type { Profile } from \"@/types/db\"\nimport type { User } from \"@supabase/supabase-js\"\n\nexport interface AuthenticatedUser {\n  user: User\n  profile: Profile\n}\n\n/**\n * Get the authenticated user and their profile.\n * Returns null if not authenticated or profile doesn't exist.\n */\nexport async function getAuthenticatedUserWithProfile(): Promise<AuthenticatedUser | null> {\n  const supabase = await createClient()\n\n  const {\n    data: { user },\n    error: authError,\n  } = await supabase.auth.getUser()\n\n  if (authError || !user) {\n    return null\n  }\n\n  const { data: profile, error: profileError } = await supabase\n    .from(\"profiles\")\n    .select(\"*\")\n    .eq(\"auth_user_id\", user.id)\n    .single()\n\n  if (profileError || !profile) {\n    return null\n  }\n\n  return { user, profile: profile as Profile }\n}\n\n/**\n * Require authentication with a specific role.\n * Redirects to login if not authenticated, or appropriate dashboard if wrong role.\n */\nexport async function requireAuth(\n  requiredRole: \"patient\" | \"doctor\",\n  options?: { allowIncompleteOnboarding?: boolean },\n): Promise<AuthenticatedUser> {\n  const authUser = await getAuthenticatedUserWithProfile()\n\n  if (!authUser) {\n    redirect(\"/auth/login\")\n  }\n\n  if (authUser.profile.role !== requiredRole) {\n    // Redirect to the correct dashboard based on role\n    if (authUser.profile.role === \"patient\") {\n      redirect(\"/patient\")\n    } else if (authUser.profile.role === \"doctor\") {\n      redirect(\"/doctor\")\n    } else {\n      redirect(\"/auth/login\")\n    }\n  }\n\n  // Check onboarding for patients (unless explicitly allowed)\n  if (requiredRole === \"patient\" && !options?.allowIncompleteOnboarding && !authUser.profile.onboarding_completed) {\n    redirect(\"/patient/onboarding\")\n  }\n\n  return authUser\n}\n\n/**\n * Sign out the current user\n */\nexport async function signOut() {\n  const supabase = await createClient()\n  await supabase.auth.signOut()\n  redirect(\"/\")\n}\n\nexport async function getOptionalAuth(): Promise<AuthenticatedUser | null> {\n  const supabase = await createClient()\n\n  const {\n    data: { user },\n    error: authError,\n  } = await supabase.auth.getUser()\n\n  if (authError || !user) {\n    return null\n  }\n\n  const { data: profile, error: profileError } = await supabase\n    .from(\"profiles\")\n    .select(\"*\")\n    .eq(\"auth_user_id\", user.id)\n    .single()\n\n  if (profileError || !profile) {\n    return null\n  }\n\n  return { user, profile: profile as Profile }\n}\n\n/**\n * Get the current authenticated user (without profile)\n */\nexport async function getCurrentUser(): Promise<User | null> {\n  const supabase = await createClient()\n  const {\n    data: { user },\n    error,\n  } = await supabase.auth.getUser()\n  if (error || !user) return null\n  return user\n}\n\n/**\n * Get a user's profile by their auth user ID\n */\nexport async function getUserProfile(authUserId: string): Promise<Profile | null> {\n  const supabase = await createClient()\n  const { data: profile, error } = await supabase.from(\"profiles\").select(\"*\").eq(\"auth_user_id\", authUserId).single()\n  if (error || !profile) return null\n  return profile as Profile\n}\n\nexport async function checkOnboardingRequired(authUser: AuthenticatedUser): Promise<boolean> {\n  return authUser.profile.role === \"patient\" && !authUser.profile.onboarding_completed\n}\n\nexport async function requirePatientAuth(options?: {\n  allowIncompleteOnboarding?: boolean\n}): Promise<AuthenticatedUser> {\n  return requireAuth(\"patient\", options)\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AAAA;;;AAaO,eAAe;IACpB,MAAM,WAAW,MAAM,IAAA,yIAAY;IAEnC,MAAM,EACJ,MAAM,EAAE,IAAI,EAAE,EACd,OAAO,SAAS,EACjB,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;IAE/B,IAAI,aAAa,CAAC,MAAM;QACtB,OAAO;IACT;IAEA,MAAM,EAAE,MAAM,OAAO,EAAE,OAAO,YAAY,EAAE,GAAG,MAAM,SAClD,IAAI,CAAC,YACL,MAAM,CAAC,KACP,EAAE,CAAC,gBAAgB,KAAK,EAAE,EAC1B,MAAM;IAET,IAAI,gBAAgB,CAAC,SAAS;QAC5B,OAAO;IACT;IAEA,OAAO;QAAE;QAAM,SAAS;IAAmB;AAC7C;AAMO,eAAe,YACpB,YAAkC,EAClC,OAAiD;IAEjD,MAAM,WAAW,MAAM;IAEvB,IAAI,CAAC,UAAU;QACb,IAAA,iMAAQ,EAAC;IACX;IAEA,IAAI,SAAS,OAAO,CAAC,IAAI,KAAK,cAAc;QAC1C,kDAAkD;QAClD,IAAI,SAAS,OAAO,CAAC,IAAI,KAAK,WAAW;YACvC,IAAA,iMAAQ,EAAC;QACX,OAAO,IAAI,SAAS,OAAO,CAAC,IAAI,KAAK,UAAU;YAC7C,IAAA,iMAAQ,EAAC;QACX,OAAO;YACL,IAAA,iMAAQ,EAAC;QACX;IACF;IAEA,4DAA4D;IAC5D,IAAI,iBAAiB,aAAa,CAAC,SAAS,6BAA6B,CAAC,SAAS,OAAO,CAAC,oBAAoB,EAAE;QAC/G,IAAA,iMAAQ,EAAC;IACX;IAEA,OAAO;AACT;AAKO,eAAe;IACpB,MAAM,WAAW,MAAM,IAAA,yIAAY;IACnC,MAAM,SAAS,IAAI,CAAC,OAAO;IAC3B,IAAA,iMAAQ,EAAC;AACX;AAEO,eAAe;IACpB,MAAM,WAAW,MAAM,IAAA,yIAAY;IAEnC,MAAM,EACJ,MAAM,EAAE,IAAI,EAAE,EACd,OAAO,SAAS,EACjB,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;IAE/B,IAAI,aAAa,CAAC,MAAM;QACtB,OAAO;IACT;IAEA,MAAM,EAAE,MAAM,OAAO,EAAE,OAAO,YAAY,EAAE,GAAG,MAAM,SAClD,IAAI,CAAC,YACL,MAAM,CAAC,KACP,EAAE,CAAC,gBAAgB,KAAK,EAAE,EAC1B,MAAM;IAET,IAAI,gBAAgB,CAAC,SAAS;QAC5B,OAAO;IACT;IAEA,OAAO;QAAE;QAAM,SAAS;IAAmB;AAC7C;AAKO,eAAe;IACpB,MAAM,WAAW,MAAM,IAAA,yIAAY;IACnC,MAAM,EACJ,MAAM,EAAE,IAAI,EAAE,EACd,KAAK,EACN,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;IAC/B,IAAI,SAAS,CAAC,MAAM,OAAO;IAC3B,OAAO;AACT;AAKO,eAAe,eAAe,UAAkB;IACrD,MAAM,WAAW,MAAM,IAAA,yIAAY;IACnC,MAAM,EAAE,MAAM,OAAO,EAAE,KAAK,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,YAAY,MAAM,CAAC,KAAK,EAAE,CAAC,gBAAgB,YAAY,MAAM;IAClH,IAAI,SAAS,CAAC,SAAS,OAAO;IAC9B,OAAO;AACT;AAEO,eAAe,wBAAwB,QAA2B;IACvE,OAAO,SAAS,OAAO,CAAC,IAAI,KAAK,aAAa,CAAC,SAAS,OAAO,CAAC,oBAAoB;AACtF;AAEO,eAAe,mBAAmB,OAExC;IACC,OAAO,YAAY,WAAW;AAChC"}},
    {"offset": {"line": 251, "column": 0}, "map": {"version":3,"sources":["file:///Users/rey/Desktop/instantmed/instantmed-main/lib/stripe/checkout.ts"],"sourcesContent":["\"use server\"\n\nimport { stripe, getPriceIdForRequest, type ServiceCategory } from \"./client\"\nimport { createClient } from \"@/lib/supabase/server\"\nimport { getAuthenticatedUserWithProfile } from \"@/lib/auth\"\n\ninterface CreateCheckoutInput {\n  category: ServiceCategory\n  subtype: string\n  type: string\n  answers: Record<string, unknown>\n}\n\ninterface CheckoutResult {\n  success: boolean\n  checkoutUrl?: string\n  error?: string\n}\n\nfunction getBaseUrl(): string {\n  // Try NEXT_PUBLIC_SITE_URL first\n  let baseUrl = process.env.NEXT_PUBLIC_SITE_URL\n\n  // Fallback to VERCEL_URL for Vercel deployments\n  if (!baseUrl && process.env.VERCEL_URL) {\n    baseUrl = `https://${process.env.VERCEL_URL}`\n  }\n\n  // Final fallback to localhost\n  if (!baseUrl) {\n    baseUrl = \"http://localhost:3000\"\n  }\n\n  // Ensure URL doesn't have trailing slash\n  return baseUrl.replace(/\\/$/, \"\")\n}\n\nfunction isValidUrl(url: string): boolean {\n  try {\n    new URL(url)\n    return true\n  } catch {\n    return false\n  }\n}\n\n/**\n * Create a request and Stripe checkout session\n * Now links Stripe customer to profile and uses existing customer if available\n */\nexport async function createRequestAndCheckoutAction(input: CreateCheckoutInput): Promise<CheckoutResult> {\n  try {\n    // 1. Get authenticated user\n    const authUser = await getAuthenticatedUserWithProfile()\n    if (!authUser) {\n      return { success: false, error: \"You must be logged in to submit a request\" }\n    }\n\n    const patientId = authUser.profile.id\n    const patientEmail = authUser.user.email\n\n    // 2. Get the Supabase client\n    const supabase = await createClient()\n\n    const baseUrl = getBaseUrl()\n    if (!isValidUrl(baseUrl)) {\n      console.error(\"Invalid base URL configuration:\", baseUrl)\n      return { success: false, error: \"Server configuration error. Please contact support.\" }\n    }\n\n    // 3. Create the request with pending_payment status\n    const { data: request, error: requestError } = await supabase\n      .from(\"requests\")\n      .insert({\n        patient_id: patientId,\n        type: input.type,\n        status: \"pending\",\n        category: input.category,\n        subtype: input.subtype,\n        paid: false,\n        payment_status: \"pending_payment\",\n      })\n      .select()\n      .single()\n\n    if (requestError || !request) {\n      console.error(\"Error creating request:\", requestError)\n      if (requestError?.code === \"23503\") {\n        return { success: false, error: \"Your profile could not be found. Please sign out and sign in again.\" }\n      }\n      if (requestError?.code === \"42501\") {\n        return { success: false, error: \"You don't have permission to create requests. Please contact support.\" }\n      }\n      return { success: false, error: \"Failed to create your request. Please try again.\" }\n    }\n\n    // 4. Insert the answers\n    const { error: answersError } = await supabase.from(\"request_answers\").insert({\n      request_id: request.id,\n      answers: input.answers,\n    })\n\n    if (answersError) {\n      console.error(\"Error creating answers:\", answersError)\n      // Don't fail the whole request, answers are supplementary\n    }\n\n    // 5. Get the price ID\n    const priceId = getPriceIdForRequest({\n      category: input.category,\n      subtype: input.subtype,\n      answers: input.answers,\n    })\n\n    if (!priceId) {\n      console.error(\"No price ID found for:\", input.category, input.subtype)\n      // Clean up the created request\n      await supabase.from(\"requests\").delete().eq(\"id\", request.id)\n      return { success: false, error: \"Unable to determine pricing. Please contact support.\" }\n    }\n\n    // 6. Build success and cancel URLs with validation\n    const successUrl = `${baseUrl}/patient/requests/success?request_id=${request.id}&session_id={CHECKOUT_SESSION_ID}`\n    const cancelUrl = `${baseUrl}/patient/requests/cancelled?request_id=${request.id}`\n\n    // 7. Build checkout session params\n    const sessionParams: Parameters<typeof stripe.checkout.sessions.create>[0] = {\n      line_items: [\n        {\n          price: priceId,\n          quantity: 1,\n        },\n      ],\n      mode: \"payment\",\n      success_url: successUrl,\n      cancel_url: cancelUrl,\n      metadata: {\n        request_id: request.id,\n        patient_id: patientId,\n        category: input.category,\n        subtype: input.subtype,\n      },\n    }\n\n    if (authUser.profile.stripe_customer_id) {\n      sessionParams.customer = authUser.profile.stripe_customer_id\n    } else {\n      sessionParams.customer_email = patientEmail || undefined\n      sessionParams.customer_creation = \"always\" // Always create a customer for new users\n    }\n\n    // 8. Create Stripe checkout session\n    let session\n    try {\n      session = await stripe.checkout.sessions.create(sessionParams)\n    } catch (stripeError: unknown) {\n      console.error(\"Stripe error:\", stripeError)\n      await supabase.from(\"requests\").delete().eq(\"id\", request.id)\n\n      if (stripeError instanceof Error) {\n        if (stripeError.message.includes(\"Invalid URL\")) {\n          return { success: false, error: \"Server configuration error. Please contact support.\" }\n        }\n        if (stripeError.message.includes(\"No such price\")) {\n          return { success: false, error: \"This service is temporarily unavailable. Please try again later.\" }\n        }\n      }\n      return { success: false, error: \"Payment system error. Please try again.\" }\n    }\n\n    if (!session.url) {\n      // Clean up\n      await supabase.from(\"requests\").delete().eq(\"id\", request.id)\n      return { success: false, error: \"Failed to create checkout session. Please try again.\" }\n    }\n\n    // 9. Create payment record\n    const { error: paymentError } = await supabase.from(\"payments\").insert({\n      request_id: request.id,\n      stripe_session_id: session.id,\n      amount: session.amount_total || 0,\n      currency: session.currency || \"aud\",\n      status: \"created\",\n    })\n\n    if (paymentError) {\n      console.error(\"Error creating payment record:\", paymentError)\n      // Don't fail - the payment record is for tracking, Stripe is the source of truth\n    }\n\n    return { success: true, checkoutUrl: session.url }\n  } catch (error) {\n    console.error(\"Error in createRequestAndCheckoutAction:\", error)\n    return {\n      success: false,\n      error: \"Something went wrong. Please try again or contact support if the problem persists.\",\n    }\n  }\n}\n\n/**\n * Retry payment for an existing request with pending_payment status\n * Now uses existing Stripe customer if available\n */\nexport async function retryPaymentForRequestAction(requestId: string): Promise<CheckoutResult> {\n  try {\n    // 1. Get authenticated user\n    const authUser = await getAuthenticatedUserWithProfile()\n    if (!authUser) {\n      return { success: false, error: \"You must be logged in\" }\n    }\n\n    const patientId = authUser.profile.id\n    const patientEmail = authUser.user.email\n\n    // 2. Get the Supabase client\n    const supabase = await createClient()\n\n    // 3. Fetch the existing request with ownership check\n    const { data: request, error: requestError } = await supabase\n      .from(\"requests\")\n      .select(\"*\")\n      .eq(\"id\", requestId)\n      .eq(\"patient_id\", patientId)\n      .single()\n\n    if (requestError || !request) {\n      console.error(\"Error fetching request for retry:\", requestError)\n      return { success: false, error: \"Request not found\" }\n    }\n\n    // 4. Verify the request is in pending_payment status\n    if (request.payment_status !== \"pending_payment\") {\n      return { success: false, error: \"This request has already been paid or is not awaiting payment\" }\n    }\n\n    // 5. Get the price ID using existing request data\n    const priceId = getPriceIdForRequest({\n      category: request.category as ServiceCategory,\n      subtype: request.subtype || \"\",\n      answers: {},\n    })\n\n    // 6. Get base URL for redirects\n    const baseUrl = getBaseUrl()\n    if (!isValidUrl(baseUrl)) {\n      console.error(\"Invalid base URL configuration:\", baseUrl)\n      return { success: false, error: \"Server configuration error. Please contact support.\" }\n    }\n\n    // 7. Build checkout session params\n    const sessionParams: Parameters<typeof stripe.checkout.sessions.create>[0] = {\n      line_items: [\n        {\n          price: priceId,\n          quantity: 1,\n        },\n      ],\n      mode: \"payment\",\n      success_url: `${baseUrl}/patient/requests/success?request_id=${request.id}&session_id={CHECKOUT_SESSION_ID}`,\n      cancel_url: `${baseUrl}/patient/requests/cancelled?request_id=${request.id}`,\n      metadata: {\n        request_id: request.id,\n        patient_id: patientId,\n        category: request.category || \"\",\n        subtype: request.subtype || \"\",\n        is_retry: \"true\",\n      },\n    }\n\n    if (authUser.profile.stripe_customer_id) {\n      sessionParams.customer = authUser.profile.stripe_customer_id\n    } else {\n      sessionParams.customer_email = patientEmail || undefined\n      sessionParams.customer_creation = \"always\"\n    }\n\n    // 8. Create new Stripe checkout session for retry\n    let session\n    try {\n      session = await stripe.checkout.sessions.create(sessionParams)\n    } catch (stripeError: unknown) {\n      console.error(\"Stripe error:\", stripeError)\n      await supabase.from(\"requests\").delete().eq(\"id\", request.id)\n\n      if (stripeError instanceof Error) {\n        if (stripeError.message.includes(\"Invalid URL\")) {\n          return { success: false, error: \"Server configuration error. Please contact support.\" }\n        }\n        if (stripeError.message.includes(\"No such price\")) {\n          return { success: false, error: \"This service is temporarily unavailable. Please try again later.\" }\n        }\n      }\n      return { success: false, error: \"Payment system error. Please try again.\" }\n    }\n\n    if (!session.url) {\n      // Clean up\n      await supabase.from(\"requests\").delete().eq(\"id\", request.id)\n      return { success: false, error: \"Failed to create checkout session. Please try again.\" }\n    }\n\n    // 9. Update or insert payment record for this new session\n    const { error: paymentError } = await supabase.from(\"payments\").upsert(\n      {\n        request_id: request.id,\n        stripe_session_id: session.id,\n        amount: session.amount_total || 0,\n        currency: session.currency || \"aud\",\n        status: \"created\",\n      },\n      {\n        onConflict: \"request_id\",\n      },\n    )\n\n    if (paymentError) {\n      console.error(\"Error updating payment record:\", paymentError)\n      // Don't fail - the payment record is for tracking, Stripe is the source of truth\n    }\n\n    return { success: true, checkoutUrl: session.url }\n  } catch (error) {\n    console.error(\"Error in retryPaymentForRequestAction:\", error)\n    return {\n      success: false,\n      error: \"Something went wrong. Please try again or contact support if the problem persists.\",\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 588, "column": 0}, "map": {"version":3,"sources":["file:///Users/rey/Desktop/instantmed/instantmed-main/lib/supabase/service-role.ts"],"sourcesContent":["import { createClient } from \"@supabase/supabase-js\"\n\n// Service role client bypasses RLS - use only in server actions for admin operations\nexport function createServiceRoleClient() {\n  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!\n  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY!\n\n  return createClient(supabaseUrl, serviceRoleKey, {\n    auth: {\n      autoRefreshToken: false,\n      persistSession: false,\n    },\n  })\n}\n"],"names":[],"mappings":";;;;AAAA;;AAGO,SAAS;IACd,MAAM;IACN,MAAM,iBAAiB,QAAQ,GAAG,CAAC,yBAAyB;IAE5D,OAAO,IAAA,uLAAY,EAAC,aAAa,gBAAgB;QAC/C,MAAM;YACJ,kBAAkB;YAClB,gBAAgB;QAClB;IACF;AACF"}},
    {"offset": {"line": 608, "column": 0}, "map": {"version":3,"sources":["file:///Users/rey/Desktop/instantmed/instantmed-main/app/actions/create-profile.ts"],"sourcesContent":["\"use server\"\n\nimport { createServiceRoleClient } from \"@/lib/supabase/service-role\"\n\nexport async function createOrGetProfile(\n  authUserId: string,\n  fullName: string,\n  dateOfBirth: string,\n): Promise<{ profileId: string | null; error: string | null }> {\n  const supabase = createServiceRoleClient()\n\n  try {\n    // First verify the user exists in auth.users\n    const { data: authUser, error: authError } = await supabase.auth.admin.getUserById(authUserId)\n\n    if (authError || !authUser?.user) {\n      return {\n        profileId: null,\n        error: \"User not found. Please confirm your email first.\",\n      }\n    }\n\n    // Check if profile already exists\n    const { data: existingProfile } = await supabase\n      .from(\"profiles\")\n      .select(\"id\")\n      .eq(\"auth_user_id\", authUserId)\n      .single()\n\n    if (existingProfile) {\n      // Update with the provided info if we have it\n      if (fullName || dateOfBirth) {\n        await supabase\n          .from(\"profiles\")\n          .update({\n            ...(fullName && { full_name: fullName }),\n            ...(dateOfBirth && { date_of_birth: dateOfBirth }),\n          })\n          .eq(\"id\", existingProfile.id)\n      }\n\n      return { profileId: existingProfile.id, error: null }\n    }\n\n    // Create new profile - user is verified to exist\n    const { data: newProfile, error: insertError } = await supabase\n      .from(\"profiles\")\n      .insert({\n        auth_user_id: authUserId,\n        full_name: fullName || \"User\",\n        date_of_birth: dateOfBirth || null,\n        role: \"patient\",\n        onboarding_completed: false,\n      })\n      .select(\"id\")\n      .single()\n\n    if (insertError) {\n      console.error(\"Profile insert error:\", insertError)\n      return { profileId: null, error: insertError.message }\n    }\n\n    return { profileId: newProfile.id, error: null }\n  } catch (err) {\n    console.error(\"createOrGetProfile error:\", err)\n    return { profileId: null, error: err instanceof Error ? err.message : \"Failed to create profile\" }\n  }\n}\n"],"names":[],"mappings":";;;;;AAEA;;;;AAEO,eAAe,mBACpB,UAAkB,EAClB,QAAgB,EAChB,WAAmB;IAEnB,MAAM,WAAW,IAAA,6JAAuB;IAExC,IAAI;QACF,6CAA6C;QAC7C,MAAM,EAAE,MAAM,QAAQ,EAAE,OAAO,SAAS,EAAE,GAAG,MAAM,SAAS,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC;QAEnF,IAAI,aAAa,CAAC,UAAU,MAAM;YAChC,OAAO;gBACL,WAAW;gBACX,OAAO;YACT;QACF;QAEA,kCAAkC;QAClC,MAAM,EAAE,MAAM,eAAe,EAAE,GAAG,MAAM,SACrC,IAAI,CAAC,YACL,MAAM,CAAC,MACP,EAAE,CAAC,gBAAgB,YACnB,MAAM;QAET,IAAI,iBAAiB;YACnB,8CAA8C;YAC9C,IAAI,YAAY,aAAa;gBAC3B,MAAM,SACH,IAAI,CAAC,YACL,MAAM,CAAC;oBACN,GAAI,YAAY;wBAAE,WAAW;oBAAS,CAAC;oBACvC,GAAI,eAAe;wBAAE,eAAe;oBAAY,CAAC;gBACnD,GACC,EAAE,CAAC,MAAM,gBAAgB,EAAE;YAChC;YAEA,OAAO;gBAAE,WAAW,gBAAgB,EAAE;gBAAE,OAAO;YAAK;QACtD;QAEA,iDAAiD;QACjD,MAAM,EAAE,MAAM,UAAU,EAAE,OAAO,WAAW,EAAE,GAAG,MAAM,SACpD,IAAI,CAAC,YACL,MAAM,CAAC;YACN,cAAc;YACd,WAAW,YAAY;YACvB,eAAe,eAAe;YAC9B,MAAM;YACN,sBAAsB;QACxB,GACC,MAAM,CAAC,MACP,MAAM;QAET,IAAI,aAAa;YACf,QAAQ,KAAK,CAAC,yBAAyB;YACvC,OAAO;gBAAE,WAAW;gBAAM,OAAO,YAAY,OAAO;YAAC;QACvD;QAEA,OAAO;YAAE,WAAW,WAAW,EAAE;YAAE,OAAO;QAAK;IACjD,EAAE,OAAO,KAAK;QACZ,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO;YAAE,WAAW;YAAM,OAAO,eAAe,QAAQ,IAAI,OAAO,GAAG;QAA2B;IACnG;AACF;;;IA/DsB;;AAAA,+OAAA"}},
    {"offset": {"line": 683, "column": 0}, "map": {"version":3,"sources":["file:///Users/rey/Desktop/instantmed/instantmed-main/.next-internal/server/app/medical-certificate/request/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {createRequestAndCheckoutAction as '401a12b18a53110d49d6bfa58fb8595aac90eaf7b4'} from 'ACTIONS_MODULE0'\nexport {createOrGetProfile as '70777e9dffada85dde3d0effd1f4fd3572ca32c38b'} from 'ACTIONS_MODULE1'\n"],"names":[],"mappings":";AAAA;AACA"}}]
}